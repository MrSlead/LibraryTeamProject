# О проекте
### ORM, БД

В данном разделе будет описано об ORM (Object-Relational Mapping) и о самой структуре БД проекта. Существует **восемь** сущностей, разделяющихся на две группы: основная и второстепенная. Основная группа делится на две еще подгруппы: предметная и регистрационная. Своего рода получается вот такая схема:
 - Основная (6 сущностей)
    - Предметная (4 сущности: Book, Language, Genre, Author)
    - Регистрационная (2 сущности: Client, Role)
 - Второстепенная (2 сущности: LnkBookGenre, LnkBookAuthor)

Самая простые сущности - это Client и Role. О них можно и не говорить. Начнем с предметной областью и со второстепенной группой. 

Введем эквивалентые отношения между сущностями. Если что-то говорится об одном, то все относится и к другому. 
Book & Genre (LnkBookGenre) = Book & Author (LnkBookGenre)


- Второстепенные сущности корректно создаются ТОЛЬКО при наличии существующих данных в БД. Если эти сущности создавать через объекты, которых еще нет в БД, то помимо второстепенной сущности будут созданы и объекты (они будут иметь только ID), что не является корректным поведением.

```java
Book book = new Book(null, "book", new Date(), null, 32);
Author author = new Author(null, "surname", "name", "patronymic");
LnkBookAuthor lnkBookAuthor = new LnkBookAuthor(new LnkBookAuthorKey(), book, author);
        
lnkBookAuthorRepository.save(lnkBookAuthor);
```

В данном примере Вы можете увидеть, что сущности book и author не имеют ID (имеют null), поэтому они считаются новыми записями. Когда объект lnkBookAuthor будет сохранен в БД, то сохранятся и сущности book и author в таблицы Book и Author соответственно. 

lnk_book_author
| author_id | book_id | 
|:---------:|:---------:|
| 1 | 1 |

book
| id | name | date_of_publication | number_of_pages | language_id |
|:---------:|:---------:|:---------:|:---------:|:---------:|
| 1 | null | null | null | null |

author
| id | name | patronymic | surname |
|:---------:|:---------:|:---------:|:---------:|
| 1 | null | null | null |

Причем записи в book и author будут принимать id в соответствии со следующим значением в seq. Это связано с внутренней работой аннотации @MapsId, вынуждающей добавлять несуществующие сущности в БД. Чтобы избежать такой проблемы, необходимо сущностям (book и author) указывать конкретные идентификаторы, действительно хранящиеся в БД. 

- Если удалена запись в Book, Genre или Author, то запись удаляется и в LnkBookGenre\LnkBookAuthor. Это связано с тем, что LnkBookGenre и LnkBookAuthor представляются сущностями многие-ко-многим. Поэтому если удалена какая-то запись из ранее указанных сущностей, то запись в LnkBookGenre или LnkBookAuthor будет неконсистентной (неверной). Поэтому в Book, Genre и Author добавлено ``` cascade = CascadeType.REMOVE ```.


- Если новая запись содержит ID, который уже существует в БД, то запись с этим ID будет заменена новой записью. Если новая запись содержит ID, которого нет в БД, то новая запись будет добавлена в БД с тем ID, указанный в seq.

Это связано с тем, что JPA предоставляет для сохранения\обновления сущности только один метод - save. Но данное поведение в нашем проекте разделено на два: save и update. Поэтому если сохраняется (save) объект с каким-то указанным уже идентификатором, то объект не будет сохранен (id должен быть равен null). Если идет обновление (update) объекта, то у этого объекта идентификатор должен быть не null и этот идентификатор должен храниться в БД.

#### Book & Language
Между этими сущностями описана односторонняя связь @ManyToOne. Данная аннотация проставлена в сущности Book. Это связано с тем, что нам необходимо знать, содержание книги на каком языке написано. И нас не интересует, какой язык обладает каким-либо количеством книг. Поэтому в сущности Language отсутствует аннотация @OneToMany, благодаря которой мы могли бы получать множество идентификаторов книг, относящихся к конкретному языку (сущности Language). 

Описание пару моментов, относящихся к этой связи:
- Любая запись в таблице Book может быть успешно удалена. Запись в таблице Language не будет удалена до тех пор, пока не будут отсутствовать записи в таблице Book, указывающие на запись Language.
 
```
1. Удаление записи в таблице Book.
```
<br/>

Language
| id | name | 
|:---------:|:---------:|
| 1 | en |

Book
| id | name | date_of_publication | number_of_pages | language_id |
|:---------:|:---------:|:---------:|:---------:|:---------:|
| 1 | book | 20-12-2001 | 640 | 1 |

**/ удаляем запись в Book /**

Language
| id | name | 
|:---------:|:---------:|
| 1 | en |

Book
| id | name | date_of_publication | number_of_pages | language_id |
|:---------:|:---------:|:---------:|:---------:|:---------:|
|  |  |  |  |  |

**Запись удалилась без ошибок.**

```
2. Удаление записи в таблице Language.
```

Language
| id | name | 
|:---------:|:---------:|
| 1 | en |

Book
| id | name | date_of_publication | number_of_pages | language_id |
|:---------:|:---------:|:---------:|:---------:|:---------:|
| 1 | book | 20-12-2001 | 640 | 1 |



**/ удаляем запись в Language /**

**Ошибка!!! Существует запись в таблице Book, которая ссылается на запись в таблице Language.**
Чтобы избежать такое поведение и действительно удалить запись, необходимо в аннотации @ManyToOne добавить ``` cascade = CascadeType.REMOVE ```.
Но это чревато тем, что удалится запись и в Book.

**/ С включенным CascadeType.REMOVE при удалении записи в Language /**

Language
| id | name | 
|:---------:|:---------:|
|  |  |

Book
| id | name | date_of_publication | number_of_pages | language_id |
|:---------:|:---------:|:---------:|:---------:|:---------:|
|  |  |  |  |  |

Поэтому эта опция не включена (она попросту удаляет и запись в таблице Language при удалении записи в таблице Book).

- Если создается новая запись в Book с новой записью Language, то при сохранении записи в таблицу Book будет выдана ошибка. Это связано с тем, что не указан каскадный тип PERSIST. При создании записи Book необходима уже СУЩЕСТВУЮЩАЯ запись в Language.

```java
Language language = new Language(null, "en");
Book book = new Book(null, "book", new Date(), language, 32);

bookRepository.save(book);
```

В данном примере показано, что объект language изначально содержит индентификатор со значением null (считается новым объектом для БД). Этот language используется для создания объекта book. Но объект book мы не сможем сохранить, потому что объект language не содержит конкретный идентификатор, хранящийся в БД. Чтобы избежать такое поведение и сохранить объект book в таблицу Book и объект language в таблицу Language, необходимо включить ``` cascade = CascadeType.PERSIST ```.
